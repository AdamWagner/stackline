


- ————————————————————————————————————————————————————————————————————————————————
- Find removed windows
- ————————————————————————————————————————————————————————————————————————————————


    -- TODO: need to delete windows that no longer exist AT ALL from the stack
    Stack.win_str = tut.t2s(ws) -- convert table to a string to avoid traversal for simple check
    win_str = tut.t2s(ws) -- convert table to a string to avoid traversal for simple check
    -- hs.alert.show(type(self.wsStr))

    -- FIXME: This REALLY slows down switching if the active indicator
    -- TODO: Run on-demand via hammerspoon window-watcher callback 
    -- CLEAN CACHE WHEN WINDOWS ARE CLOSED
    -- Find windows in stack cache that have been removed:
    --  (closed, minimized, etc)
    --  and destroy / delete them
    function find_removed_windows(wsid, win_str)
        local win_still_exists = string.match(Stack.win_str, wsid)

        local win = Stack:findWindow(wsid)
        _.p(win)
        -- hs.alert.show('all window stack ids:')
        -- hs.alert.show(win.stackId)

        if type(win_still_exists) == 'nil' then
            stale_win = Stack:findWindow(wsid)
            _.p(stale_win)
            _.pheader('stale window!!!!!!!!!!!!!!!!')
            print('removing window id: ', stale_win.id)
            print('stale win app: ', stale_win.app)
            print('stale win stack id: ', stale_win.stackId)

            hs.alert.show('stale window stack ids:')
            hs.alert.show(stale_win.stackId)

            stale_win.indicator:delete()
            hs.alert.show(stale_win.stackId)
            self.tabStacks[stale_win.stackId][stale_win.id] = nil
        end
    end








- —————————————————————————————————————————————————————————————————————————————
- stack.lua old backup
- —————————————————————————————————————————————————————————————————————————————



-- luacheck: ignore
mm = require 'mm'
flatten = require 'utils.flatten'

_ = require 'utils'

-- [[ INSPO
-- ┬┌┐┌┌─┐┌─┐┬┬─┐┌─┐┌┬┐┬┌─┐┌┐┌
-- ││││└─┐├─┘│├┬┘├─┤ │ ││ ││││
-- ┴┘└┘└─┘┴  ┴┴└─┴ ┴ ┴ ┴└─┘┘└┘
-- Seems similar to what I'm doing, but it didn't run w/ SpoonInstall so I
-- haven't used it yet
-- https://github.com/macrael/panes/blob/master/Panes.spoon/window_set.lua
--
-- See how they manage window indicators:
--  + single (full-frame) canvas
--  + window methods set indicator = nil to kill
-- https://github.com/xcv58/Hammerspoon-xcv58/blob/master/hammerspoon/window.lua#L249
--
-- Ki status-display
-- https://github.com/andweeb/ki/blob/master/src/status-display.lua
-- He clears canvas elements *in the draw method*! This might work well, esp.  for updating

--  Another project, Indicator_KE.lua, does the same thing: https://github.com/spring-haru/.hammerspoon/blob/master/Indicator_KE.lua

--  Yet another project has a similar take:
--     if canvas then
--        canvas:delete()
--     end
--     https://github.com/thenoseman/zsh_config/blob/master/home/.hammerspoon/msteams.lua
-- -----------------------------------------------------------------------------
-- Clear any pre-existing status display canvases
--      for state, display in pairs(self.displays) do
--         if display ~= nil then
--             display:delete()
--             self.displays[state] = nil
--         end
--      end
-- -----------------------------------------------------------------------------
--
-- HSWM - very clean
-- https://github.com/NTT123/hswm/blob/master/window.lua
-- See how they manage tracking borders on windows as they're moved / resized
--
--
-- preocas.lua (asmagill)
-- https://github.com/asmagill/hammerspoon-config-take2/blob/master/preocas.lua
-- Complicated canvas stuff.
--
-- Uses metatables to do canvas stuff. I don't really get it.
-- https://github.com/asmagill/hammerspoon-config-take2/blob/master/utils/_actions/_off/quickPreview.lua
--
-- Status bar
-- Not *that* useful, for my purposes
-- https://github.com/goweiwen/dotfiles/tree/master/hammerspoon/.hammerspoon/bar
--
-- Dashboard
-- https://github.com/hollandan/hammerspoon/blob/master/dashboard.lua
-- This looks a little too simple, which might mean it's worth a second look later
--
-- CommandPost Colorboard
-- https://github.com/CommandPost/CommandPost/blob/develop/src/plugins/finalcutpro/touchbar/widgets/colorboard.lua
-- The opposite of above, this is *complicated*!
-- Lots of state management, but not sure how applicable it is for me.
--
-- Statuslets
-- Note how cmsj handles lifecycle & destroying / updating
-- https://github.com/cmsj/hammerspoon-config/blob/master/statuslets.lua
-- ]]
-- [[ NOTES on companion shell scripts
--
-- CREATE NEW FRAME FIELD TO GROUP BY
-- yabai -m query --windows --window | jq '.frameFlat = "\(.frame.x)|\(.frame.y)|\(.frame.w)|\(.frame.h)"'
--
-- CALL HAMMERSPOON WITH YABAI WINDOW DATA (using `hs` cli)

-- VERSION 2: Group by exact x,y position only, NOT width & height. 
--            This allows windows that have size constraints to be grouped
--            together (e.g. when calculator is stacked with kitty, it'll have
--            same x,y — but NOT same w,h)
--
--            NOTE: Also, the wsi object changed to return a table of methods,
--            and so is no longer called with : but rather . -> wsi.add(…)
-- yabai -m query --windows --space | jq 'map(del(.title)) | map(select(.subrole == "AXStandardWindow"))' \
--        | jq 'map(.frameFlat = "\(.frame.x)|\(.frame.y)") | group_by(.frameFlat)' \
--        | jq -R --raw-output |  tr -d \n \
--        | tr '\t' ' ' \
--        | tr -s '' \
--        | xargs -0 -n20 -I{} hs -c "wsi.stackTabs('{}')"

-- VERSION 1: Require x,y,w,h of windows to match exactly
-- yabai -m query --windows --space | jq 'map(del(.title)) | map(select(.subrole == "AXStandardWindow"))' \
--        | jq 'map(.frameFlat = "\(.frame.x)|\(.frame.y)|\(.frame.w)|\(.frame.h)") | group_by(.frameFlat)' \
--        | jq -R --raw-output |  tr -d \n \
--        | tr '\t' ' ' \
--        | tr -s '' \
--        | xargs -0 -n20 -I{} hs -c "wsi:stackTabs('{}')"
--
-- ]]

-- TODO: Upgrade to lua 5.4 when it's release on homebrew:

-- ┌───────────────────┐
-- │ Private functions │
-- └───────────────────┘
function iconFromAppName(appName)
    appBundle = hs.appfinder.appFromName(appName):bundleID()
    return hs.image.imageFromAppBundle(appBundle)
end

-- Provides a window class that keeps track of state
local lib = {}

function lib.indicatorAttrs(w, attr)
    -- local stack = self:get()[s.id]
    -- local window = stack.windows[w.id]
    local indicator = w.indicator
    local indicatorAttr = indicator:elementAttribute(1, attr)

    return {
        window = _.pick(w, {'id', 'app'}),
        indicator = {[attr] = indicatorAttr}
    }
end

function lib:windowAttrs(s, attr)
    print('running window attrs')
    result = {}
    local stack = self:get()[s.id]
    _.each(stack.windows, function(w)
        local window = stack.windows[w.id]
        local indicator = window.indicator
        local indicatorAttr = _.pick(indicator:elementAttribute(1, attr),
                                     {'alpha'})

        table.insert(result, flatten({
            stack = stack.id,
            window = w.id,
            flatten(indicatorAttr)
        }))
    end)
    return result
end

local Window = {}

function Window:new(id, focused, frame)
    local ws = {
        id = id, -- window id
        indicator = nil, -- the canvas element
        focused = focused, -- 0 if unfocused, 1 if focused
        frame = frame, -- x,y,w,h of window
        needsUpdated = nil, -- bool when set
        needsCreated = nil -- bool when set
    }

    setmetatable(ws, self)
    self.__index = self
    return ws
end

function Window:get()
    return {
        id = self.id,
        frame = self.frame,
        focused = self.focused,
        needsUpdated = self.needsUpdated,
        needsCreated = self.needsCreated,
        indicator = self.indicator
    }
end

function Window:setIndicator(indicator) self.indicator = indicator end

function Window:getIndicator() return self.indicator end

function Window:setNeedsCreated(bool) self.needsCreated = bool end

function Window:setNeedsUpdated(extant)
    existComp = {
        id = extant.id,
        frame = extant.frameFlat,
        focused = extant.focused
    }
    currComp = {id = self.id, frame = self.frameFlat, focused = self.focused}
    local isEqual = _.isEqual(existComp, currComp)
    self.needsUpdated = not isEqual
end

-- ┌────────────────┐
-- │ Public methods │
-- └────────────────┘
-- luacheck: ignore
function lib:processWindow(window, currTabIdx, numTabs)
    local w = window -- abbreviate "window"

    -- NEW attempt with 'win' object (getters and setters to avoid userdata issues)
    local win = Window:new(w.id, w.focused, w.frame)

    -- print(w.app)
    -- print(w.id)
    local existing = self:findWindow(w.id)
    local e = existing
    -- print('after find existing')

    local needsUpdated = nil
    local needsCreated = nil

    if existing ~= nil then
        -- -- _.pheader('existing')
        -- existComp = {id = e.id, frame = e.frameFlat, focused = e.focused}
        -- currComp = {id = w.id, frame = w.frameFlat, focused = w.focused}
        -- -- _.p(existComp)
        -- -- _.p(currComp)
        -- local isEqual = _.isEqual(existComp, currComp)
        -- needsUpdated = not isEqual
        win:setNeedsUpdated(existing)
    else
        win:setNeedsCreated(true)
    end

    print('Need to update or create?', (needsUpdated or needsCreated))
    print('Need to update?', needsUpdated)

    print('needs updated ->', win.needsUpdated)
    print('needs created ->', win.needsCreated)
    -- _.p(win)
    if (win.needsUpdated == false and win.needsCreated == nil) then
        _.pheader('existing early!')
        _.p(existing)
        return existing
    end

    _.p('got past early exit')

    if win.needsUpdated or win.needsCreated then
        -- Clear existing indicator
        if win.needsUpdated then
            -- _.p(e)
            if e then
                if e.indicator ~= nil then
                    -- _.pheader('removing existing indiactor')
                    -- _.p(e.indicator)
                    -- TODO: Don't delete, just update fillColor.alpha
                    -- e.indicator.fillColor.alpha = 0.35
                    -- return nil
                    e.indicator:delete()
                    e.indicator = nil
                end
            end
        end

        -- Config
        local unfocused_color = {white = 0.9, alpha = 0.15}
        local focused_color = {white = 1, alpha = 0.9}
        local padding = 5
        local tabWidth = 25
        local tw = tabWidth

        -- Computed vars
        local top = ((currTabIdx - 1) * tw * 1.1)
        -- local tw_half = tabWidth / 2

        -- _.pheader('window in processWindow()')
        -- _.p(_.pick(w, {'id', 'app', 'frame'}))

        -- TODO: fix active tab computation: stack-index is static, it does NOT change
        -- when focus within the stack changes.
        local focused = w.focused == 1
        local stackIndex = w['stack-index']
        local isTop = stackIndex == 1

        -- local bg = isTop and focused_color or unfocused_color
        local bg = focused and focused_color or unfocused_color
        -- local canvasAlpha = isTop and 1 or 0.5
        local canvasAlpha = focused and 1 or 0.2
        local imageAlpha = focused and 1 or 0.4

        -- _.p(stackIndex, numTabs, isTop, canvasAlpha)

        width = self.showIcons and tw or (tw / 3)

        indicator = hs.canvas.new {
            x = (w.frame.x - (width + padding)),
            y = w.frame.y,
            h = w.frame.h,
            w = w.frame.w
        }

        indicator:appendElements({
            type = "rectangle",
            action = "fill",
            fillColor = bg,
            frame = {x = 0, y = top, w = width, h = tw},
            roundedRectRadii = {xRadius = 2.0, yRadius = 2.0}
        })

        if self.showIcons then
            indicator:appendElements({
                type = "image",
                image = iconFromAppName(w.app),
                frame = {x = 0, y = top, w = tw, h = tw},
                imageAlpha = imageAlpha
            })
        end
    end

    -- indicator:appendElements({
    --     type="text",
    --     text="fuck",
    --     textAlignment='center',
    --     textSize=9,
    --     frame={x=0, y=0, w=tw, h=tw}
    --   })

    -- INDICATOR IS SET IN IF BLOCK, SO IS USERDATA, SO IS NOT ACCESSIBLE HERE
    -- TODO!!! The PROBLEM IS HERE: 
    -- w.indicator = indicator
    -- _.p(win)
    win:setIndicator(indicator)
    -- _.pheader('finished processing window')
    -- _.pheader('window before returning to thingy')
    winx = win:get()
    -- _.p(winx)
    return winx
end

function lib:updateWindow(window, currTabIdx, numTabs)
    _.pdivider()
    _.p('Not implemented.')
end

function lib:toggleIcons()
    self:cleanup()
    self.showIcons = not self.showIcons

    for key, stack in pairs(self.tabStacks) do
        local numTabs = #stack.windows
        for key, window in pairs(stack.windows) do
            window = self:processWindow(window, key, numTabs)
            print('got here')
            print(window)
            _.pheader('window in stack make')
            _.p(window)
            stack.windows[window.id] = window
            window.indicator:show()
        end
    end
end

function drawIndicators(window)
    -- body
end

function lib:cleanup()
    -- DEBUG:
    -- NOTE: Can't figure out how to print the # of tab stacks, since they're
    -- associative arrays indexed on concatenation of window IDs in stack

    _.p('# to be cleaned: ', _.length(self.tabStacks))
    _.p('keys be cleaned: ', _.keys(self.tabStacks))

    for key, stack in pairs(self.tabStacks) do
        -- DEBUG:
        -- _.p(stack)
        _.pheader('stack keys')
        _.p(_.map(stack.windows, function(w)
            return _.pick(w, {'id', 'app'})
        end))
        -- _.p(_.pick(stack, {'id', 'app', 'frame'}))

        -- For each window, clear canvas element
        _.each(stack.windows, function(w)

            -- w.indicator = nil

            -- NOTE: Don't actually need to remove window from stack windows,
            -- since we're going to delete the stack altogether at the end.
            --    stack.windows[w.id] = nil

            -- DEBUG:
            -- _.pdivider('w.indicator')
            -- _.p(w.indicator)

            w.indicator:delete()

        end)

        self.tabStacks[key] = nil
    end
    -- TODO: Decide whether to clear each stack via self.stabStacks[key] = nil,
    -- or all at once at the end like this:
    -- self.tabStacks = {}
end

-- function lib:draw()

--   for key, window in ipairs(self.tabStacks)
--   do
--     window = self:processWindow(window, key, numTabs)
--     window.indicator:show()
--   end

-- end

function lib:newStack(windowGroup)
    local numTabs = #windowGroup
    local tabStack = {}
    tabStack.windows = {}

    print('numTabs: ', numTabs)
    for key, window in pairs(windowGroup) do
        winx = self:processWindow(window, key, numTabs)

        -- print('win in new stack)', window.app, window.id)
        _.pheader('win returned from process window')
        _.p(winx)

        tabStack.windows[window.id] = winx
        if winx.needsCreated or winx.needsUpdated then
            -- if winx.indicator then winx.indicator:show() end
            _.pheader('test')
            _.p(winx.indicator)
            winx.indicator:show()
            winx.needsCreated = nil
        end
    end

    -- table.insert(self.tabStacks, tabStack)
    tabStackId = _.map(tabStack.windows, function(w) return w.id end)
    tabStack['id'] = table.concat(tabStackId, '')
    self.tabStacks[tabStack['id']] = tabStack
end

function lib:getLen()
    result = _.length(lib:get())
    return result
end

function lib:getState()
    if pcall(self.getLen, self) then
        print("Success")
        numStacks = self:getLen()

        if numStacks > 0 then
            local wAttrs = _.map(self:get(), function(stack)
                return self:windowAttrs(stack, 'fillColor')
            end)
            -- _.p(wAttrs)
        end
    else
        print("Failure")
    end
end

-- NOTE: A window must be *in* a stack to be found with this method!
function lib:findWindow(wid)
    for idx, stack in pairs(self:get()) do
        match = stack.windows[wid]
        if match then return match end
    end
end

function lib:ingest(tabStackData)
    -- hs.alert.show(self.tabStacks)
    -- self:cleanup()

    ws = hs.json.decode(tabStackData)

    -- Only keep the *stacks*, which are tables with > 1 entry
    local stacks = hs.fnutils.filter(ws, function(windowGroup)
        return #windowGroup > 1
    end)

    -- Track result and create a new tabStack for each
    _.each(stacks, function(stack) self:newStack(stack) end)
end

function lib:get() return self.tabStacks end

function lib:newStackManager()
    self.tabStacks = {}
    self.showIcons = false
    return {
        ingest = function(d) return self:ingest(d) end,
        cleanup = function() return self:cleanup() end,
        toggleIcons = function() return self:toggleIcons() end,
        get = function() return self:get() end,
        getState = function() return self:getState() end,
        findWindow = function(wid) return self:findWindow(wid) end
    }
end

return lib
