#!/usr/local/bin/dash

# ↑ dash for fast startup

# HELP {{{
usage() {
cat <<-EOF
USAGE
 Called by hammerspoon module 'stackline' on the following events:
   windowCreated, windowUnhidden, windowUnminimized,
   windowDestroyed, windowHidden, windowMinimized,
   windowMoved, windowFocused, windowUnfocused,
   windowFullscreened, windowUnfullscreened
 See ../stackline/core.lua

RETURNS window stack data 
  as a json array of "stacks"
  where each stack is an array of windows:
  [
    [    
      { "id": "123abc", … },  
      {…},
      {…},
      {…},
    ],              
    […]
  ]                        

DEPENDS on 'yabai' & 'jq'
EOF
}
if [ "$1" = "-h" ] || [ "$1" = "--help" ] ; then
  usage
  exit 1
fi
# }}}

# Set path per /etc/paths
#   Ensures that non-standard binaries `yabai` & `jq` are available
#   Alternatively, you may specify absolute paths
PATH=$(/usr/libexec/path_helper)

# The unfortunate `sleep` command
#   Sadly, on a 16" "macbook pro, at least 0.03 delay 
#   is required to ensure `yabai -m query …` returns the focused window and not
#   the *previously* focused window.
#   Without the sleep, the active stacked-window indicator remains on the
#   previously active stacked-window once every ~1 in 5 focus events —
#   particularly when changing focus rapidly.

#   Why does yabai query occasionally not return new state 
#   when called by Hammerspoon's `hs.window.filter.windowFocused` event?
#   Hypothesis: if a yabai query blocks a subsequent query, sequential calls may
#   accumulate and eventually fall behind the current state? Actually, this
#   doesn't really make sense, wouldn't this mean the last call would be *late*,
#   and therefore be slow, but reflect the latest state?

#   ALTERNATIVE? 
#   For events that will certainly result in a stack indicator update (e.g., windowFocused),
#   we could call this continuously w/ exponential backoff *until the response is different*.
#   This seems like it would provide the best of both worlds: responsive updates
#   when the yabai query reflects the change, and eventual consistency when it doesn't.
#   The cost is additional calls to `yabai -m query …`, which may be significant.
#   There may be other costs I'm not considering, e.g., what happens when there 
#   are 5 focus events in 5 seconds?
sleep 0.03

# The main course
yabai -m query --windows --space \
  | jq --raw-output --compact-output --monochrome-output '
      map(del(.title))                             # titles may break lua json parsing
    | map(select(
      .subrole == "AXStandardWindow" and  
      .visible == 1))                              # minimized == 0 may be preferrable?
    | map(.frameFlat = "\(.frame.x)|\(.frame.y)")  # frame x,y to string to group wins → stacks
    | sort_by(.["stack-index"])
    | group_by(.frameFlat)                         # … the aforementioned grouping
    | map(select(length > 1))                      # we only care about *stacks*, which contain > 1 window
    ' 

