local _ = require 'stackline.utils.utils'
local Window = require 'stackline.stackline.window'
local u = require 'stackline.utils.underscore'
local tut = require 'stackline.utils.table-utils'
local under = require 'stackline.utils.underscore'

local query = require 'stackline.stackline.WIP-query'

local log = hs.logger.new('[stack]', 'debug')

local Stack = {}

-- TODO: include hs.task functionality from core.lua in the Stack module directly

function Stack:toggleIcons() -- {{{
    self.showIcons = not self.showIcons
    Stack.update()
end -- }}}

-- function Stack:each_win_id(fn) -- {{{
--     _.each(self.tabStacks, function(stack)
--         -- hs.alert.show('running each win id')
--         -- _.pheader('stack')
--         -- _.p(stack)
--         -- _.p(under.values(stack))
--         local winIds = _.map(under.values(stack), function(w)
--             return w.id
--         end)
--         -- print(hs.inspect(winIds))

--         for i = 1, #winIds do
--             -- ┌────────────────────┐
--             --     the main event! 
--             -- └────────────────────┘
--             -- hs.alert.show(winIds[i])

--             fn(winIds[i]) -- Call the `fn` provided with win ID

--             -- hs.alert.show('inside final loop')

--             -- DEBUG
--             -- print(hs.inspect(winIds))
--             -- print(winIds[i])
--         end
--     end)
-- end -- }}}

function Stack:findWindow(wid) -- {{{
    -- NOTE: A window must be *in* a stack to be found with this method!
    for _idx, stack in pairs(self.tabStacks) do
        extantWin = stack[wid]
        if extantWin then
            return extantWin
        end
    end
end -- }}}

function Stack:cleanup() -- {{{
    -- _.p('# to be cleaned: ', _.length(self.tabStacks))
    -- _.p('keys be cleaned: ', _.keys(self.tabStacks))

    for key, stack in pairs(self.tabStacks) do
        -- DEBUG: {{{
        -- _.p(stack)
        -- _.pheader('stack keys')
        -- _.p(_.map(stack, function(w)
        --     return _.pick(w, {'id', 'app'})
        -- end)) }}}

        -- For each window, clear canvas element
        _.each(stack, function(w)
            -- _.pheader('window indicator in cleanup')
            -- print(w.indicator)
            w.indicator:delete()
        end)

        self.tabStacks[key] = nil
    end
end -- }}}

_.pheader('running again!')
local cache = {}

function Stack:newStack(stack, stackId) -- {{{
    -- DEBUG {{{
    -- _.pheader('cache')
    -- _.p(cache)

    _.pheader('NEWSTACK')
    -- print('stack window #:', #stack)
    -- print('stack ID: ', stackId) }}}
    local extantStack = self.tabStacks[stackId]
    self.tabStacks[stackId] = extandStack or {}

    for winIdx, w in pairs(stack) do
        if not extantStack then -- it's the first run {{{
            _.pheader('First run')
            local win = Window:new(w)

            -- win:setStackIdx() {{{
            -- NOTE: blocking task
            -- TODO: retrieve all window stack indexes in one yabai query and
            -- weave into windows instead of calling each window }}}

            win:process(self.showIcons, winIdx)
            win.indicator:show()

            self.tabStacks[stackId][win.id] = win

            win.cacheWin = win
            win.cacheWin.focus = win:isFocused()
            cache[win.id] = win -- }}}
        else -- if extantStack *does* exist {{{
            local extantWin = extantStack[w.id].cacheWin
            local win = Window:new(w)

            local noExtantWin = (type(extantWin) == 'nil')
            local sameFocus = (extantWin.focus == win:isFocused())
            local shouldRedrawIndicator = (noExtantWin or not sameFocus)

            print('should redraw? ', shouldRedrawIndicator)

            if shouldRedrawIndicator then
                extantWin.indicator:delete()
                win:process(self.showIcons, winIdx)
                win.indicator:show()
                win.stackId = stackId -- set stackId on win for easy lookup later
                self.tabStacks[stackId][win.id] = win
            end
        end -- if extantStack exists }}}
    end
end -- }}}

function Stack:ingest(windowData) -- {{{
    for stackId, stackWindows in pairs(windowData) do
        Stack:newStack(stackWindows, stackId)
    end
end -- }}}

function Stack:update(shouldClean) -- {{{
    if shouldClean then -- {{{
        _.pheader('running cleanup')
        Stack:cleanup()
    end -- }}}

    query:windowsCurrentSpace() -- calls Stack:ingest when ready
    -- Stack:ingest(newState)

    -- DEBUG {{{
    -- print('\n\n\n\n')
    -- _.pheader('self.tabStack after update')
    -- self:get()
    -- _.pheader('focused windows')
    -- _.p(hs.fnutils.map(self:get(), function(stack)
    --     _.each(stack, function(w)
    --         print(w.id, ' is ', w.focused)
    --     end)
    -- end))
    -- print('\n\n\n\n')

    -- OLD ---------------------------------------------------------------------
    -- -- _.pheader('value of "shouldClean:"')
    -- -- _.p(shouldClean)
    -- -- print('\n\n')
    -- if shouldClean then
    --     _.pheader('running cleanup')
    --     Stack:cleanup()
    -- end

    -- local yabai_get_stacks = 'stackline/bin/yabai-get-stacks'

    -- hs.task.new("/usr/local/bin/dash", function(_code, stdout)
    --     local windowData = hs.json.decode(stdout)
    --     Stack:ingest(windowData)
    -- end, {yabai_get_stacks}):start() }}}

end -- }}}

function Stack:get(shouldPrint) -- {{{
    if shouldPrint then
        _.p(self.tabStacks, 3)
    end
    return self.tabStacks
end -- }}}

function Stack:newStackManager() -- {{{
    self.tabStacks = {}
    self.showIcons = false
    return {
        ingest = function(windowData)
            return self:ingest(windowData)
        end,
        get = function()
            return self:get()
        end,
        getCache = function()
            return cache
        end,
        update = self.update,
        cleanup = function()
            return self:cleanup()
        end,
        toggleIcons = function()
            return self:toggleIcons()
        end,
        findWindow = function(wid)
            return self:findWindow(wid)
        end,
        each_win = function(wid)
            return self:each_win_id(wid)
        end,
        get_win_str = function()
            return Stack.win_str
        end,
    }
end -- }}}

return Stack

